## 周总结

本周主要学习内容主要围绕『分布式』来展开，包括如下内容：
1. 分布式数据库
2. NoSQL
3. 案例分享：Doris - 分布式海量KV存储引擎
4. 分布式环境一致性解决方案：Zookeeper

### 1. 分布式数据库

#### 数据库复制

- 主从复制： 实现读写分离，提高读写效率
- 主主复制： 实现写数据的高可用


注意事项：

- 主主复制两个数据库不能并发写入
- 复制只增加读操作的并发处理能力，没有增加并发写能力和存储能力
- 更新表结构会导致巨大的延时，最好手动进行操作



#### 数据分片： 大数据量存储

实现方式：

- 硬编码实现数据分片
- 映射表外部存储： 比硬编码灵活，实际情况很少使用，因为使用映射表需要多一次查询请求，此外映射表也可能成为存储瓶颈 
- 分布式数据库中间件（分为客户端中间件和服务器中间件）

如何做到集群扩容： 

和缓存不一样，数据库扩容时数据一条都不能丢失，必须进行数据迁移

数据库的分片数量不变(分片数量大于服务器数量)，每台数据库服务器上创建多个schema，迁移时以schema为单位进行迁移即可。减少每个服务器上schema的数量


#### 数据库部署架构演化

- 单一服务器和单一数据库
- 主从复制提升读写性能
- 业务划分为多个应用，数据库也进行对应的业务分库 
- 综合部署 - 在业务分库的基础上，针对特定的业务需求做数据分片或复制（通常在没有实现业务分库之前不需要考虑数据分片)


### 2. NOSQL

#### CAP原理

一个分布式系统在满足分区耐受性的前提下，一致性和可用性是无法同时满足的

- 一致性 Consistency - 每次读取的数据应该是最新的数据或返回一个错误，不能是过期的数据 
- 可用性 Availablity - 每次请求都应该得到一个响应，而不应该返回错误或失去响应，但并不保证数据是最新的
- 分区耐受性 Partition Tolarance -  因为网络原因部分服务器节点不可用了，系统依然应该是可以操作的


在架构领域，很多情况下鱼和熊掌是不可兼得的


#### 数据最终一致性处理策略

- 简单处理： 根据时间戳，最后写入覆盖
- 客户端解决冲突 （应用层根据一定的规则解决数据冲突，不推荐）
- 投票解决冲突 （Cassandra)

保证数据一致性是分布式系统必须面对的重大考验



#### ACID:事务的四个特征

- 原子性 Atomicity  - 事务要么全部完成，要么全部取消
- 一致性 Consistency - 事务前后的数据完整性必须保证一致
- 隔离性 Isolation - 多个并发事务之前要相互隔离
- 持久性 Durability - 一旦事务提交，数据要永久保存


#### BASE理论： CAP中对可用性和一致性权衡的结果 

- 基本可用 Basically Available  
分布式系统出现故障时，保证核心功能可用，允许损失部分可用性

- 弱状态 Soft State  
允许系统中的数据存在中间状态，并认为该中间状态不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时

- 最终一致性 Eventually consistent  
最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。
ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性。


### 3. 案例分享：Doris - 分布式海量KV存储引擎

如何说服别人接受你的方案，做你想做的事？  
1. 描述当前现状
2. 根据当前存在的问题提炼出产品需求
3. 确定产品目标


Doris的优点：

1. 性能优于『一致性哈希』的算法（Doris系统最核心的技术）
2. 虚拟节点物理化，这样扩展时只需要对整个物理文件进行复制即可。
3. 比其它开源产品更友好的用户管理界面及功能

### 分布式环境一致性解决方案：Zookeeper

分布式系统脑裂: Zooker主要解决的问题
分布式一致性算法： Paxos




