## 导致系统不可用的原因有哪些？保障系统稳定高可用的方案有哪些？请分别列举并简述。

### 系统不可用的原因及解决方案

#### 硬件故障

- 备份： 集群部署，数据库主主，主从复制
- 失效转移

#### 软件bug

- 隔离
- 解耦（在设计和代码层面）: 先写好代码，做好设计
- 幂等： 服务重复调用，结果和调用一次产生的结果相同。
- 单元测试
- 事务补偿
- 重试
- 熔断

#### 系统发布

- 分批发布保证发布过程中系统一直可用。
- 自动化测试
- 自动化部署
- 持续部署
- 预发布验证
- 代码版本控制
- 灰度发布
- 网站运行监控

#### 并发压力

- 隔离
- 异步 : 一个功能的故障不会影响另一个功能
- 限流
- 降级

#### 网络攻击

- 防火墙
- 隔离
- 网站运行监控

#### 外部灾害

- 异地多活多机房
- 失效转移

### 解决方案详细说明

#### 高可用系统架构方案

##### 解耦（在设计和代码层面） -  先写好代码，做好设计

- 高内聚，低耦合的组件设计原则 
- 面向对象基本设计原则 
- 面向对象设计模式
- 领域驱动设计建模


##### 隔离 （物理层面）- 一个系统的故障不会影响另一个系统

- 业务与子系统隔离
- 微服务中台架构
- 生产者消费者隔离
- 虚拟机与容器隔离


##### 异步 - 一个功能的故障不会影响另一个功能

- 多线程编程
- 反应式编程
- 异步网络通信编程
- 事件驱动异步架构

##### 备份

- 集群部署
- 数据库复制（主从，主主）

##### 失效转移（failover) - 前提： 设计无状态的服务

- 数据库主主失效转移
- 负载均衡失效转移

##### 幂等： 服务重复调用，结果和调用一次产生的结果相同。

##### 事务补偿

- 传统事务的ACID
- 分布式事务的BASE（基本可用,弱状态，最终一致性）
- 事务补偿：通过执行业务逻辑逆操作，使事务回滚

##### 重试

##### 熔断

当某个服务响应延迟或失败率增加，使用断路器阻断对该服务的调用，使用请求快速失败，避免资源消耗。

##### 限流

在高并场景下，当访问量超过系统处理能力时，使用限流对系统进行保护。 

限流算法：

- 计数器算法 （固定窗口 / 滑动窗口)
- 令牌桶算法: 令牌桶按固定速度放令牌，直到令牌桶放满，请求到达时先向令牌桶请求令牌。
- 漏桶算法： 请求进入时进入漏桶，如容量达到限流值，则将请求放弃，漏桶以固定的算法释放请求。


自适应限流：不是通过人工评估QPS,而是根据运行期的性能指标，实时计算系统的处理能力。


##### 降级

在系统高并发时，关闭非核心功能，将系统资源留给核心的有价值的功能。

##### 异地多活多机房

即使某一个机房不可用，系统仍然可以提供服务。

异地多少的难点是数据同步。


#### 高可用系统运维

##### 发布

分批发布保证发布过程中系统一直可用。

##### 自动化测试

系统开发早期使用手工测试成本较低，在系统整体功能趋于稳定，进行更新迭代时，使用自动化测试的成功

##### 自动化部署

##### 持续部署

- 持续集成： 工程师随时向主分支提交代码，并立即进行自动化测试
- 持续交付：自动执行单元测试并发布到各种测试环境中
- 持续部署：在没有人工干预的情况下测试，构建，部署并推送到生产环境。



##### 预发布验证

预发布服务器和正式服务器的唯一区别就是没有配置在负载均衡服务器上，外部用户无法访问。开发工程师通过host域名绑定的方式访问并进行测试。

##### 代码版本控制

- 开发分支：开发工程师从主分支创建一个新的分支进行开发 。
- 测试分支：开发完成后合并到测试分支进行测试
- 发布分支：测试完成后合并到发布分支
- 主分支：发布成功后将代码合并到主分支。



##### 灰度发布

第一次只发布到一批服务器，并使系统运行一段时间，运行正常再发布到所有服务器。

##### 网站运行监控

不允许没有监控的系统上线

- 监控数据采集
- 服务器性能监控
- 业务运行数据报告
- 监控管理： 报警和自动控制


## 请用你熟悉的编程语言写一个用户密码验证函数，Boolean checkPW（String 用户 ID，String 密码明文，String 密码密文）返回密码是否正确 boolean 值，密码加密算法使用你认为合适的加密算法。

```php
public boolean function checkPw($userId, $inputPassword, $encryptedPassword)
{
	$str = $userId . $inputPassword . 'random_string'; //单向散列加密，userId + 随机字段串作为Salt
    return md5($str) === $encryptedPassword;
}
```

