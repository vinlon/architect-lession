# 周总结

## 数据结构与算法

### 时间复杂度与空间复杂度

时间复杂度： 算法执行语句的次数

空间复杂度：算法运行过程中临时占用存储空间大小



### NP问题

P问题： 能在多项式时间复杂度内『解决』的问题

NP问题：能在多项式时间复杂度内『验证答案正确与否』的问题



### 基本数据结构 

- 数组

  ```
  创建数组必须要内存中一块连续的空间
  必须存放相同的数据类型
  随机快速读写是数组的一个重要特性，数组查找时间复杂度为O(1)
  数据插入/删除时间复杂度为O(N)
  ```

- 链表

  ```
  可以使用零散的内存空间
  每个元素都必须包含指向下一下元素的内存地址指针
  链表查找时间复杂度O(N)
  增删数据比数组性能好，时间复杂度为O(1)
  ```

- Hash表

  ```
  即能快速访问，又能快速增删
  数组用于存储数据的内存地址指针。
  当出现Hash冲突时，相同的值使用链表进行存储
  ```



数组和链表都被称为线性表，在线性表的基础上增加额外的操作限制，就构成了新的数据结构

- 栈 （后进先出）

  典型应用： 线程调用栈

- 队列 （先进先出）
  典型应用：消息队列



非线性表

- 树  

典型应用：

二叉排序树：左子树上的结点都小于根节点 ，右子树上的结点都大于根节点 

平衡二叉排序树：左右子树深度之差不超过1 



一个平衡二叉树随着数据的增加可能变的不平衡，此时，需要通过旋转使二叉树恢复平衡（时间复杂度O(logN)

红黑（排序）树：

```
# 特点：
最多三次旋转就会达成红黑平衡，时间复杂度O(1)
大量增删的情况下，红黑树效率更高
平衡性不如平衡二叉树，查询效率差一些

# 典型应用： TreeMap
```

跳表：

```
实现逻辑简单
缺点： 空间复杂度较高 （空间换时间）
```



### 常用算法

- 穷举算法
- 递归算法： 方法开始时一定要判断退出逻辑
  - 快速排序算法
- 贪心算法： 每一步都找『当前』最优解，但『当前』最优解不一定是『整体』最优解
- 动态规划： 将求解的目标值在某（几）个维度上展开，将一个大问题拆解为若干个小问题，从小问题的最优角，寻找大问题的最优解


=====================


## 网络与数据库

### OSI七层模型

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层

### TCP/IP四层模型

- 应用层： HTTP协议，添加HTTP头

- 传输层: TPC协议，添加 HTTP进程监听端口，客户端通信端口

  ```
  TCP建立连接需要三次握手
  TCP关闭连接需要四次挥手
  ```

- 网络互联层: IP协议，添加服务端和客户端IP

- 网络访问（链路）层: 链路层协议，添加mac地址



### HTTP请求方法

- GET: 获取资源
- HEAD： 只返回响应头
- POST: 提交数据
- PUT: 上传文件
- DELETE: 删除数据
- TRACE: 网络诊断
- OPTION: HTTP跨域请求时需要先发送一个OPTION请求，判断是否支持跨域



#### HTTP响应状态

- 1xx: 继续处理

- 2xx: 成功

- 3xx: 重定向

- 4xx: 请求错误

- 5xx: 服务端错误



### HTTP协议版本

- HTTP/1.0: 每次请求都需要建立TCP连接，三次握手的消耗较大

- HTTP/1.1: 引入 『保持连接』的概念，允许客户端复用TCP连接，但一个连接同时时间只能处理一个请求

- HTTP/2: 引入『HTTP流』的概念，允许一个TCP连接并发处理请求，但由于TCP协议本身的限制 ，并不能真正的实现发并
- HTTP/3: 不再使用TCP作为会话的传输层，而是使用QUIC(一种新的互联网传输协议)，实现真正的并行



## 非阻塞IO

### Java NIO (NEW I/O)

- Selector
- Buffer: 读和写的数据缓存在Buffer中，读写操作与不干扰
- SelectableChannel
- SelectionKey
  - OP_READ
  - OP_WRITE
  - OP_CONNECT
  - OP_ACCEPT



## 数据库架构原理

SQL --> 连接器 --> 语法分析器 --> 语义分析与优化器 --> 执行引擎



### 连接器

为每一个连接分配专门的内存空间用于会话上下文管理，建立连接开锁较大，因此可以通过使用连接池实现数据库连接的复用，在应用程序启动时也可以初始化一些连接放到连接池里。



### 语法分析器

根据SQL语句转构建语法树



### 语义分析与优化器

对复杂SQL进行语义等价转换，最后生成执行计划



### 执行引擎



### 为什么PrepareStatement更好

1. PrepareStatement会预告提交带占位符的SQL到数据库进行预处理，提前生成执行计划，当给定占位符后，直接执行即可. 
2. 防止SQL注入



### 数据库主要的一种存储结构 ： B+ 树

一张表就是一棵B+树



### 索引 

- 聚簇索引： 数据库记录和索引存储在一起，索引的叶子节点是数据行记录

  ```
  MySql主键使用的就是聚簇索引
  ```

- 非聚簇索引： 索引的叶子节点不是数据行记录，而是聚簇索引 

  ```
  通过非聚簇索引找到聚簇索引，再通过聚簇索引找到数据行记录，这个过程也叫『回表』
  ```

##### 合理使用索引 

- 不要盲目的使用索引 （任何收益都是有代价的）
  - 添加索引耗时较长
  - 添加索引期间数据库CRUD全部阻塞

- 删除不用的索引
- 使用更少的数据类型建立索引 



### 数据库事务

- 事务原子性ACID

- 通过事务日志实现事务

  ```
  进行事务操作时，事务日志文件会记录更新前的数据记录
  ```

  



### 数据库优化

- 添加必要的数据库索引 ，优化SQL查询性能